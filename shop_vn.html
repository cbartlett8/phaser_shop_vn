<!doctype html> 
<html lang="en"> 
<head> 
	<meta charset="UTF-8" />
	<title>Phaser - Making your first game, part 2</title>
    <script src="assets/cb_generic_text_box.js"></script>
    <script src="assets/helper.js"></script>
    <script src="assets/phaser_2_10_0.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">

var game = new Phaser.Game(800, 600, Phaser.CANVAS, '');//, { preload: preload, create: create, update: update });

var player_name = "Chris"; // Just the default name the Actors will call the player.
var actor_pos_x = game.width / 2;
var actor_pos_y = game.height / 2;
var textbox_pos_x = 0;
var textbox_pos_y = (game.height / 3) * 2;
var actor = null;
var actor_order_array = [];
var actor_order_index = 0;
var dialog_array = [];
var more_text_array = [];
var background_group = null;
var middle_group = null;
var front_group = null;
var hud_group = null;
var cursors = null;
var space_key = null; 
var load_complete = false;
var script_loader = null;
var loading_text = null;

function loadStart()
{
  console.log("loadStart Starting...");
  game.load.image('sky', 'assets/sky.png');
  game.load.image('ground', 'assets/platform.png');
  game.load.image('star', 'assets/star.png');
  game.load.image('actor', 'assets/actor.png');
  game.load.image('textbox', 'assets/textbox.png');
  game.load.spritesheet('dude', 'assets/dude.png', 32, 48);
}

function fileComplete(progress, cacheKey, success, totalLoaded, totalFiles)
{
  loading_text.setText("File Complete: " + progress + "% - " + totalLoaded + " out of " + totalFiles);
  /*
  if (totalLoaded == totalFiles)
  {
    load_complete=true;
  }
  */
}

function loadComplete()
{
  loading_text.text = "Load Complete.";
  console.log("Load Complete called.");
  load_complete = true;
}

var bootState = {
  preload: function()
  {
    console.log("Boot State.");
    // loading the text files.
    game.load.text('order',   'assets/day_1/order.txt');
    game.load.text('clark_1', 'assets/day_1/clark/clark_1.txt');
    game.load.text('irene_1', 'assets/day_1/irene/irene_1.txt');
    game.load.text('maggy_1', 'assets/day_1/maggy/maggy_1.txt');
    game.load.text('maggy_2', 'assets/day_1/maggy/maggy_2.txt');
    game.load.text('test', 'assets/day_1/maggy/test.txt');
    
    //game.state.start('load');
  },
  create: function()
  {
    game.state.start('load');
  }
};

var loadState = {
  preload: function()
  {
    loading_text = game.add.text(32, 32, 
      'Loading...', { fill: '#ffffff' });

    console.log("Load State.");
    game.load.image('__missing', 'assets/missing.png');
    
    game.load.onLoadStart.add(loadStart, this);
    game.load.onFileComplete.add(fileComplete, this);
    game.load.onLoadComplete.add(loadComplete, this);
  },
  create()
  {
    console.log("loadState:create: " + game.load.progress);
  },
  update()
  {
    //console.log("loadState:update");
    //console.log("loadState:progress: " + game.load.progress);
    if (game.cache.getText('clark_1') != null)
    { console.log("Finished loading?"); game.state.start('game'); }
  }
};

/* 
 Generic Class for the Actors that the player will be interacting with in the game.
 They have an entrance str, exit str, and favorite saying, then the strings that
  will hold their dialog.
 Every Actor will have sprites assicaited with them, be it a happy, sad, 
  angry, confused, flustered.
 When the actor is created they are displayed to the screen as the player is 
  interacting with them.
 When the player is done talking to them they are distroyed.
  param game * = The game instance
  param script_handle file_handle = The file cashed into memory of the browsers handle.
  param string_array [] = The array that will hold the string data.
  param spritesheet sprite_handle = The name of the sprite handle we are
    instantiaing.
*/
class Actor
{
  constructor(game, entry_str, exit_str, saying_str, script_handle, 
    string_array, spritesheet)
  {
    this.m_game = game;
    //game.add.sprite(0,0,'textbox');
    
    if (game == null)
    {
     console.error("ERROR::Actor:constructor: game is null?");
     return; 
    }
    
    // dialog
    this.m_str_entry = entry_str;
    this.m_str_exit = exit_str;
    this.m_str_saying = saying_str;
    this.m_str_array = string_array;
    
    
    // sprites
    this.m_spritesheet_name = spritesheet;
    
    // sprite setup
    this.m_actor_sprite = game.add.sprite(actor_pos_x, actor_pos_y, this.m_spritesheet_name);
    this.m_actor_sprite.animations.add('idle', [0,1,2,3], 30, true);
    this.m_actor_sprite.animations.add('happy', [1,2,3,4], 30, true);
    this.m_actor_sprite.animations.add('sad', [2,3,4,5], 30, true);
    this.m_actor_sprite.animations.add('angry', [3,4,5,6], 30, true);
    this.m_actor_sprite.animations.add('confused', [4,5,6,7], 30, true);
    this.m_actor_sprite.animations.add('flustered', [5,6,7,8], 30, true);
    
    this.m_actor_sprite.animations.play('idle');
   
    // Places the dialog for the Actor in the dialog_array. 
    this.m_more = parseTextCache(script_handle, 1);
    if (this.m_more != null)
    {
      // We have a more text object to create.
      parseTextCache(this.m_more, 2)
    }
    
    // Display the dialog object.
    this.m_textbox = new GenericTextBox(this.m_game, textbox_pos_x, textbox_pos_y,
      3, dialog_array, 3,100);
      
    // BETA TESTING ONLY HERE!!!!
    this.m_actions_array = [];
    this.m_actions_array.length = 100;
    this.m_actions_array.fill(0);
    
    this.m_action_counter = 0;
    
  }
  
  advanceText()
  {
    this.m_action_counter += 1;
    
    if (this.m_actions_array[this.m_action_counter] != 0)
    {
      this.m_actor_sprite.animations.stop();
      // We have to change the emotion state of the actor to the new
      // state.
      switch(this.m_actions_array[this.m_action_counter])
      {
        case 0:
          this.m_actor_sprite.animations.play('idle');
          break;
        case 1:
          this.m_actor_sprite.animations.play('happy');
          break;
        case 2:
          this.m_actor_sprite.animations.play('sad');
          break;
        case 3:
          this.m_actor_sprite.animations.play('angry');
          break;
        case 4:
          this.m_actor_sprite.animations.play('confused');
          break;
        case 5:
          this.m_actor_sprite.animations.play('flustered');
          break;
        default:
          console.error("ERROR::Actor:advanceText:actions outside bound.");
      }
    }

    // Returns true on good to continue or false when there is 
    // no text to advance to.
    if (this.m_textbox.advanceText() == false)
    {
      // We got to the end of the actor dialog, destroy.
      this.destroy();
      return false;
    }
    return true;
  }
  
  destroy()
  {
    console.log("Actor:destroy: Got called.");
    dialog_array.length = 0;
    this.m_actions_array.length = 0;
    this.m_actor_sprite.destroy();
  }
}

// Here is just a generic class that keeps track of the current button states.
class Button
{
  constructor()
  {
    this.m_state = false;
  }
  
  getState()
  {
    return this.m_state;
  }
  
  updateState(state)
  {
    this.m_state = state;
  }
}

// Button states
var button_left = new Button();
var button_right = new Button();
var button_up = new Button();
var button_down = new Button();
var button_space = new Button();



/*
  This function will parse the text cashed into the browser and
  place it into the dialog_array.
  @param name str = The name of the cashe were the text is located.
  @param mode int = The mode for where to place the text.
      1: dialog_array
      2: more_text_array
*/
function parseTextCache(name, mode)
{
  let error_str = "ERROR::parseTextCache:";
  if (!testVarValidity(mode, 'number', 0,3,error_str))
  { console.error(" " + mode + " is not a 1 or 2. Invalid Mode."); return; }
  if (!testVarValidity(name, 'string', -123, 123, error_str))
  { 
    console.error(" " + name + " is not a string?"); 
    if (mode == 1) { dialog_array.push("ERROR"); }
    if (mode == 2) { more_text_array.push("ERROR"); }
    return;
  }

  let t = game.cache.getText('maggy_2');

  var text = game.cache.getText(name);
  // Dumb check
  if (text == null)
  {
    console.error(error_str + " text is null for "+name+ "? Thats bad...C=\"#ERROR\"");
    text = "#ERROR" + '\n' + '#';
  }
  var str = "";
  var array = [];
  let more_text_flag = false;
  var more_text_name = "";
  
  for (let i = 0; i < text.length; i++)
  {
    switch(text[i])
    {
      case '#': // # Display the name so a new textbox so new array needed.
        // REMEMBER: You must end the dialog box with a # or else the 
        // last one will not be displayed to the screen.
        if (mode == 1) { dialog_array.push(array); }
        if (mode == 2) { more_text_array.push(array); }
        array = [];
        break;
      case '\n': // '\n' A newline so a new string.
        array.push(str);
        str = "";
        break;
      case '@': // @ Emotion so update the emotion
        // update the actor_actions_array here.
        break;
      case '*': // * is just to sub in the players name, as it might be var.
        //array.push(player_name);
        str += player_name;
        break;
      case '<': // The start of the more_text_name.
        more_text_flag = true;
        break;
      case '>': // The end of the more_text_name.
        more_text_flag = false;
        break;
      default:
        if (more_text_flag == false)
        {
          str += text[i];
        }
        else
        {
          console.log("Checking name: " + text[i]);
          more_text_name += text[i];
        }
    }
  }
  if (more_text_name == "")
  {
    return null;
  }
  else
  {
    return more_text_name;
  }
}

var gameState = {
  
  preload() 
  {
    console.log("gameState:start");
    if (loading_text != null)
    {
      loading_text.text = "gameState:Done Loading?"; 
    }
    else
    {
      console.log("gameState:loading_text is not init?");
    }
    
    var array_1 = [];
    
    cursors = game.input.keyboard.createCursorKeys();
  },

  create() 
  {
    console.log("gameState:create");
      if (load_complete == true)
      {
        console.log("load_complete: " + load_complete);
        // Populate the actor_order_array
        var order_text = game.cache.getText('order'); 
        var str = "";
        for (let i = 0; i < order_text.length; i++)
        {
          switch(order_text[i])
          {
            case '\n':
              actor_order_array.push(str);
              str = "";
              break;
            default:
              str += order_text[i];
          }
        }
        if (actor_order_array.length == 0)
        {
          console.error("ERROR::gameState:create: Could not get any text from order.txt?");
          actor_order_array.push('clark_1');
        }
        // Creating the Actor
        actor = new Actor(game, "Entry Text", "Exit Text", "Nindo", 
          actor_order_array[0]+ '_1', dialog_array, 'dude');
  
        space_key = game.input.keyboard.addKey(Phaser.Keyboard.SPACEBAR);

        //game.cache.getText('maggy_2');
      }
      else
      {
        console.log("load_complete is not true?");
      }
  },

  update() 
  {
 
  //console.log("gameState:update"); 
  if (cursors.left.isDown)
  {
    if (button_left.getState() == false)
    {
      button_left.updateState(true);
    }
  }
  else if (cursors.right.isDown)
  {
    if (button_right.getState() == false)
    {
      button_right.updateState(true);
    }
  }
  else if (cursors.up.isDown)
  {
    if (button_up.getState() == false)
    {
      button_up.updateState(true);
    }
  }
  else if (cursors.down.isDown)
  {
    if (button_down.getState() == false)
    {
      button_down.updateState(true);
    }
  }
  else if (space_key != null && space_key.isDown)
  {
    if (button_space.getState() == false)
    {
      button_space.updateState(true);
      if (actor != null && actor.advanceText() == false)
      {
        // We got to the end of dialog for the current actor
        // and must get a new actor from actor_order_array.
        actor_order_index += 1;
        if (actor_order_index < actor_order_array.length)
        {
          actor = new Actor(game, "En", "Ex", "Bl", 
            actor_order_array[actor_order_index]+ '_1', dialog_array, 'dude');
        }
        else
        {
          actor = null;
        }
      
      }
    }
  }
  else
  {
    button_left.updateState(false);
    button_right.updateState(false);
    button_up.updateState(false);
    button_down.updateState(false);
    button_space.updateState(false);
  }
  }
}

// States
game.state.add('boot', bootState);
game.state.add('load', loadState);
game.state.add('game', gameState);

game.state.start('boot');

</script>

</body>
</html>
